{"version":3,"sources":["js\\resources.js","js\\app.js","js\\engine.js","index.js"],"names":["resourceCache","loading","readyCallbacks","load","urlOrArr","Array","forEach","url","_load","img","Image","onload","isReady","func","src","get","ready","k","hasOwnProperty","onReady","push","window","Resources","Enemy","sprite","x","y","prototype","update","dt","render","ctx","drawImage","Player","console","log","enemyOne","allEnemies","document","addEventListener","e","allowedKeys","player","handleInput","keyCode","Engine","global","doc","win","canvas","createElement","getContext","lastTime","width","height","body","appendChild","main","now","Date","requestAnimationFrame","init","reset","updateEntities","enemy","rowImages","numRows","numCols","row","col","clearRect","renderEntities"],"mappings":"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","file":"frontend-nanodegree-arcade-game.ae892267.map","sourcesContent":["/* Resources.js\r\n * This is simply an image loading utility. It eases the process of loading\r\n * image files so that they can be used within your game. It also includes\r\n * a simple \"caching\" layer so it will reuse cached images if you attempt\r\n * to load the same image multiple times.\r\n */\r\n(function() {\r\n    var resourceCache = {};\r\n    var loading = [];\r\n    var readyCallbacks = [];\r\n\r\n    /* This is the publicly accessible image loading function. It accepts\r\n     * an array of strings pointing to image files or a string for a single\r\n     * image. It will then call our private image loading function accordingly.\r\n     */\r\n    function load(urlOrArr) {\r\n        if(urlOrArr instanceof Array) {\r\n            /* If the developer passed in an array of images\r\n             * loop through each value and call our image\r\n             * loader on that image file\r\n             */\r\n            urlOrArr.forEach(function(url) {\r\n                _load(url);\r\n            });\r\n        } else {\r\n            /* The developer did not pass an array to this function,\r\n             * assume the value is a string and call our image loader\r\n             * directly.\r\n             */\r\n            _load(urlOrArr);\r\n        }\r\n    }\r\n\r\n    /* This is our private image loader function, it is\r\n     * called by the public image loader function.\r\n     */\r\n    function _load(url) {\r\n        if(resourceCache[url]) {\r\n            /* If this URL has been previously loaded it will exist within\r\n             * our resourceCache array. Just return that image rather\r\n             * re-loading the image.\r\n             */\r\n            return resourceCache[url];\r\n        } else {\r\n            /* This URL has not been previously loaded and is not present\r\n             * within our cache; we'll need to load this image.\r\n             */\r\n            var img = new Image();\r\n            img.onload = function() {\r\n                /* Once our image has properly loaded, add it to our cache\r\n                 * so that we can simply return this image if the developer\r\n                 * attempts to load this file in the future.\r\n                 */\r\n                resourceCache[url] = img;\r\n\r\n                /* Once the image is actually loaded and properly cached,\r\n                 * call all of the onReady() callbacks we have defined.\r\n                 */\r\n                if(isReady()) {\r\n                    readyCallbacks.forEach(function(func) { func(); });\r\n                }\r\n            };\r\n\r\n            /* Set the initial cache value to false, this will change when\r\n             * the image's onload event handler is called. Finally, point\r\n             * the image's src attribute to the passed in URL.\r\n             */\r\n            resourceCache[url] = false;\r\n            img.src = url;\r\n        }\r\n    }\r\n\r\n    /* This is used by developers to grab references to images they know\r\n     * have been previously loaded. If an image is cached, this functions\r\n     * the same as calling load() on that URL.\r\n     */\r\n    function get(url) {\r\n        return resourceCache[url];\r\n    }\r\n\r\n    /* This function determines if all of the images that have been requested\r\n     * for loading have in fact been properly loaded.\r\n     */\r\n    function isReady() {\r\n        var ready = true;\r\n        for(var k in resourceCache) {\r\n            if(resourceCache.hasOwnProperty(k) &&\r\n               !resourceCache[k]) {\r\n                ready = false;\r\n            }\r\n        }\r\n        return ready;\r\n    }\r\n\r\n    /* This function will add a function to the callback stack that is called\r\n     * when all requested images are properly loaded.\r\n     */\r\n    function onReady(func) {\r\n        readyCallbacks.push(func);\r\n    }\r\n\r\n    /* This object defines the publicly accessible functions available to\r\n     * developers by creating a global Resources object.\r\n     */\r\n    window.Resources = {\r\n        load: load,\r\n        get: get,\r\n        onReady: onReady,\r\n        isReady: isReady\r\n    };\r\n})();\r\n","// Enemies our player must avoid\r\nvar Enemy = function() {\r\n    // Variables applied to each of our instances go here,\r\n    // we've provided one for you to get started\r\n\r\n    // The image/sprite for our enemies, this uses\r\n    // a helper we've provided to easily load images\r\n    this.sprite = 'images/enemy-bug.png';\r\n    this.x = 0;\r\n    this.y = 0;\r\n};\r\n\r\n// Update the enemy's position, required method for game\r\n// Parameter: dt, a time delta between ticks\r\nEnemy.prototype.update = function(dt) {\r\n    // You should multiply any movement by the dt parameter\r\n    // which will ensure the game runs at the same speed for\r\n    // all computers.\r\n};\r\n\r\n// Draw the enemy on the screen, required method for game\r\nEnemy.prototype.render = function() {\r\n    ctx.drawImage(Resources.get(this.sprite), this.x, this.y);\r\n};\r\n\r\n// Now write your own player class\r\n// This class requires an update(), render() and\r\n// a handleInput() method.\r\n  let sprite = 'images/cha-boy.png';\r\n\r\nclass Player {\r\n  constructor(sprite) {\r\n    this.sprite = sprite;\r\n  }\r\n  update() {\r\n    Player.update = dt => {\r\n\r\n    }\r\n  }\r\n  render() {\r\n\r\n  }\r\n  handleInput() {\r\n\r\n  }\r\n}\r\nconsole.log(Player);\r\n\r\n// Now instantiate your objects.\r\n// Place all enemy objects in an array called allEnemies\r\n// Place the player object in a variable called player\r\n\r\nlet enemyOne = new Enemy();\r\nconsole.log(enemyOne);\r\nenemyOne.render();\r\n\r\nconst allEnemies = [];\r\n\r\n\r\n\r\n\r\n// This listens for key presses and sends the keys to your\r\n// Player.handleInput() method. You don't need to modify this.\r\ndocument.addEventListener('keyup', function(e) {\r\n    var allowedKeys = {\r\n        37: 'left',\r\n        38: 'up',\r\n        39: 'right',\r\n        40: 'down'\r\n    };\r\n\r\n    player.handleInput(allowedKeys[e.keyCode]);\r\n});\r\n","/* Engine.js\r\n * This file provides the game loop functionality (update entities and render),\r\n * draws the initial game board on the screen, and then calls the update and\r\n * render methods on your player and enemy objects (defined in your app.js).\r\n *\r\n * A game engine works by drawing the entire game screen over and over, kind of\r\n * like a flipbook you may have created as a kid. When your player moves across\r\n * the screen, it may look like just that image/character is moving or being\r\n * drawn but that is not the case. What's really happening is the entire \"scene\"\r\n * is being drawn over and over, presenting the illusion of animation.\r\n *\r\n * This engine makes the canvas' context (ctx) object globally available to make\r\n * writing app.js a little simpler to work with.\r\n */\r\n\r\nvar Engine = (function(global) {\r\n    /* Predefine the variables we'll be using within this scope,\r\n     * create the canvas element, grab the 2D context for that canvas\r\n     * set the canvas elements height/width and add it to the DOM.\r\n     */\r\n    var doc = global.document,\r\n        win = global.window,\r\n        canvas = doc.createElement('canvas'),\r\n        ctx = canvas.getContext('2d'),\r\n        lastTime;\r\n\r\n    canvas.width = 505;\r\n    canvas.height = 606;\r\n    doc.body.appendChild(canvas);\r\n\r\n    /* This function serves as the kickoff point for the game loop itself\r\n     * and handles properly calling the update and render methods.\r\n     */\r\n    function main() {\r\n        /* Get our time delta information which is required if your game\r\n         * requires smooth animation. Because everyone's computer processes\r\n         * instructions at different speeds we need a constant value that\r\n         * would be the same for everyone (regardless of how fast their\r\n         * computer is) - hurray time!\r\n         */\r\n        var now = Date.now(),\r\n            dt = (now - lastTime) / 1000.0;\r\n\r\n        /* Call our update/render functions, pass along the time delta to\r\n         * our update function since it may be used for smooth animation.\r\n         */\r\n        update(dt);\r\n        render();\r\n\r\n        /* Set our lastTime variable which is used to determine the time delta\r\n         * for the next time this function is called.\r\n         */\r\n        lastTime = now;\r\n\r\n        /* Use the browser's requestAnimationFrame function to call this\r\n         * function again as soon as the browser is able to draw another frame.\r\n         */\r\n        win.requestAnimationFrame(main);\r\n    }\r\n\r\n    /* This function does some initial setup that should only occur once,\r\n     * particularly setting the lastTime variable that is required for the\r\n     * game loop.\r\n     */\r\n    function init() {\r\n        reset();\r\n        lastTime = Date.now();\r\n        main();\r\n    }\r\n\r\n    /* This function is called by main (our game loop) and itself calls all\r\n     * of the functions which may need to update entity's data. Based on how\r\n     * you implement your collision detection (when two entities occupy the\r\n     * same space, for instance when your character should die), you may find\r\n     * the need to add an additional function call here. For now, we've left\r\n     * it commented out - you may or may not want to implement this\r\n     * functionality this way (you could just implement collision detection\r\n     * on the entities themselves within your app.js file).\r\n     */\r\n    function update(dt) {\r\n        updateEntities(dt);\r\n        // checkCollisions();\r\n    }\r\n\r\n    /* This is called by the update function and loops through all of the\r\n     * objects within your allEnemies array as defined in app.js and calls\r\n     * their update() methods. It will then call the update function for your\r\n     * player object. These update methods should focus purely on updating\r\n     * the data/properties related to the object. Do your drawing in your\r\n     * render methods.\r\n     */\r\n    function updateEntities(dt) {\r\n        allEnemies.forEach(function(enemy) {\r\n            enemy.update(dt);\r\n        });\r\n        player.update();\r\n    }\r\n\r\n    /* This function initially draws the \"game level\", it will then call\r\n     * the renderEntities function. Remember, this function is called every\r\n     * game tick (or loop of the game engine) because that's how games work -\r\n     * they are flipbooks creating the illusion of animation but in reality\r\n     * they are just drawing the entire screen over and over.\r\n     */\r\n    function render() {\r\n        /* This array holds the relative URL to the image used\r\n         * for that particular row of the game level.\r\n         */\r\n        var rowImages = [\r\n                'images/water-block.png',   // Top row is water\r\n                'images/stone-block.png',   // Row 1 of 3 of stone\r\n                'images/stone-block.png',   // Row 2 of 3 of stone\r\n                'images/stone-block.png',   // Row 3 of 3 of stone\r\n                'images/grass-block.png',   // Row 1 of 2 of grass\r\n                'images/grass-block.png'    // Row 2 of 2 of grass\r\n            ],\r\n            numRows = 6,\r\n            numCols = 5,\r\n            row, col;\r\n\r\n        // Before drawing, clear existing canvas\r\n        ctx.clearRect(0,0,canvas.width,canvas.height)\r\n\r\n        /* Loop through the number of rows and columns we've defined above\r\n         * and, using the rowImages array, draw the correct image for that\r\n         * portion of the \"grid\"\r\n         */\r\n        for (row = 0; row < numRows; row++) {\r\n            for (col = 0; col < numCols; col++) {\r\n                /* The drawImage function of the canvas' context element\r\n                 * requires 3 parameters: the image to draw, the x coordinate\r\n                 * to start drawing and the y coordinate to start drawing.\r\n                 * We're using our Resources helpers to refer to our images\r\n                 * so that we get the benefits of caching these images, since\r\n                 * we're using them over and over.\r\n                 */\r\n                ctx.drawImage(Resources.get(rowImages[row]), col * 101, row * 83);\r\n            }\r\n        }\r\n\r\n        renderEntities();\r\n    }\r\n\r\n    /* This function is called by the render function and is called on each game\r\n     * tick. Its purpose is to then call the render functions you have defined\r\n     * on your enemy and player entities within app.js\r\n     */\r\n    function renderEntities() {\r\n        /* Loop through all of the objects within the allEnemies array and call\r\n         * the render function you have defined.\r\n         */\r\n        allEnemies.forEach(function(enemy) {\r\n            enemy.render();\r\n        });\r\n\r\n        player.render();\r\n    }\r\n\r\n    /* This function does nothing but it could have been a good place to\r\n     * handle game reset states - maybe a new game menu or a game over screen\r\n     * those sorts of things. It's only called once by the init() method.\r\n     */\r\n    function reset() {\r\n        // noop\r\n    }\r\n\r\n    /* Go ahead and load all of the images we know we're going to need to\r\n     * draw our game level. Then set init as the callback method, so that when\r\n     * all of these images are properly loaded our game will start.\r\n     */\r\n    Resources.load([\r\n        'images/stone-block.png',\r\n        'images/water-block.png',\r\n        'images/grass-block.png',\r\n        'images/enemy-bug.png',\r\n        'images/char-boy.png'\r\n    ]);\r\n    Resources.onReady(init);\r\n\r\n    /* Assign the canvas' context object to the global variable (the window\r\n     * object when run in a browser) so that developers can use it more easily\r\n     * from within their app.js files.\r\n     */\r\n    global.ctx = ctx;\r\n})(this);\r\n","import resources from '/js/resources';\r\nimport app from '/js/app';\r\nimport engine from '/js/engine';\r\n"]}