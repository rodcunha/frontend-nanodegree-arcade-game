{"version":3,"sources":["js/engine.js"],"names":["Engine","global","doc","document","win","window","canvas","createElement","ctx","getContext","lastTime","width","height","body","appendChild","main","now","Date","dt","update","render","requestAnimationFrame","init","reset","updateEntities","allEnemies","forEach","enemy","player","rowImages","numRows","numCols","row","col","clearRect","drawImage","Resources","get","renderEntities","load","onReady"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;AAeA,IAAIA,SAAU,UAASC,MAAT,EAAiB;AAC3B;;;;AAIA,MAAIC,MAAMD,OAAOE,QAAjB;AAAA,MACIC,MAAMH,OAAOI,MADjB;AAAA,MAEIC,SAASJ,IAAIK,aAAJ,CAAkB,QAAlB,CAFb;AAAA,MAGIC,MAAMF,OAAOG,UAAP,CAAkB,IAAlB,CAHV;AAAA,MAIIC,QAJJ;;AAMAJ,SAAOK,KAAP,GAAe,GAAf;AACAL,SAAOM,MAAP,GAAgB,GAAhB;AACAV,MAAIW,IAAJ,CAASC,WAAT,CAAqBR,MAArB;;AAEA;;;AAGA,WAASS,IAAT,GAAgB;AACZ;;;;;;AAMA,QAAIC,MAAMC,KAAKD,GAAL,EAAV;AAAA,QACIE,KAAK,CAACF,MAAMN,QAAP,IAAmB,MAD5B;;AAGA;;;AAGAS,WAAOD,EAAP;AACAE;;AAEA;;;AAGAV,eAAWM,GAAX;;AAEA;;;AAGAZ,QAAIiB,qBAAJ,CAA0BN,IAA1B;AACH;;AAED;;;;AAIA,WAASO,IAAT,GAAgB;AACZC;AACAb,eAAWO,KAAKD,GAAL,EAAX;AACAD;AACH;;AAED;;;;;;;;;AASA,WAASI,MAAT,CAAgBD,EAAhB,EAAoB;AAChBM,mBAAeN,EAAf;AACA;AACH;;AAED;;;;;;;AAOA,WAASM,cAAT,CAAwBN,EAAxB,EAA4B;AACxBO,eAAWC,OAAX,CAAmB,UAASC,KAAT,EAAgB;AAC/BA,YAAMR,MAAN,CAAaD,EAAb;AACH,KAFD;AAGAU,WAAOT,MAAP;AACH;;AAED;;;;;;AAMA,WAASC,MAAT,GAAkB;AACd;;;AAGA,QAAIS,YAAY,CACR,wBADQ,EACoB;AAC5B,4BAFQ,EAEoB;AAC5B,4BAHQ,EAGoB;AAC5B,4BAJQ,EAIoB;AAC5B,4BALQ,EAKoB;AAC5B,4BANQ,CAMoB;AANpB,KAAhB;AAAA,QAQIC,UAAU,CARd;AAAA,QASIC,UAAU,CATd;AAAA,QAUIC,GAVJ;AAAA,QAUSC,GAVT;;AAYA;AACAzB,QAAI0B,SAAJ,CAAc,CAAd,EAAgB,CAAhB,EAAkB5B,OAAOK,KAAzB,EAA+BL,OAAOM,MAAtC;;AAEA;;;;AAIA,SAAKoB,MAAM,CAAX,EAAcA,MAAMF,OAApB,EAA6BE,KAA7B,EAAoC;AAChC,WAAKC,MAAM,CAAX,EAAcA,MAAMF,OAApB,EAA6BE,KAA7B,EAAoC;AAChC;;;;;;;AAOAzB,YAAI2B,SAAJ,CAAcC,UAAUC,GAAV,CAAcR,UAAUG,GAAV,CAAd,CAAd,EAA6CC,MAAM,GAAnD,EAAwDD,MAAM,EAA9D;AACH;AACJ;;AAEDM;AACH;;AAED;;;;AAIA,WAASA,cAAT,GAA0B;AACtB;;;AAGAb,eAAWC,OAAX,CAAmB,UAASC,KAAT,EAAgB;AAC/BA,YAAMP,MAAN;AACH,KAFD;;AAIAQ,WAAOR,MAAP;AACH;;AAED;;;;AAIA,WAASG,KAAT,GAAiB,CAEhB;AADG;;;AAGJ;;;;AAIAa,YAAUG,IAAV,CAAe,CACX,wBADW,EAEX,wBAFW,EAGX,wBAHW,EAIX,sBAJW,EAKX,qBALW,CAAf;AAOAH,YAAUI,OAAV,CAAkBlB,IAAlB;;AAEA;;;;AAIArB,SAAOO,GAAP,GAAaA,GAAb;AACH,CAzKY,CAyKV,IAzKU,CAAb","file":"engine.a1355c00.map","sourcesContent":["/* Engine.js\n * This file provides the game loop functionality (update entities and render),\n * draws the initial game board on the screen, and then calls the update and\n * render methods on your player and enemy objects (defined in your app.js).\n *\n * A game engine works by drawing the entire game screen over and over, kind of\n * like a flipbook you may have created as a kid. When your player moves across\n * the screen, it may look like just that image/character is moving or being\n * drawn but that is not the case. What's really happening is the entire \"scene\"\n * is being drawn over and over, presenting the illusion of animation.\n *\n * This engine makes the canvas' context (ctx) object globally available to make\n * writing app.js a little simpler to work with.\n */\n\nvar Engine = (function(global) {\n    /* Predefine the variables we'll be using within this scope,\n     * create the canvas element, grab the 2D context for that canvas\n     * set the canvas elements height/width and add it to the DOM.\n     */\n    var doc = global.document,\n        win = global.window,\n        canvas = doc.createElement('canvas'),\n        ctx = canvas.getContext('2d'),\n        lastTime;\n\n    canvas.width = 505;\n    canvas.height = 606;\n    doc.body.appendChild(canvas);\n\n    /* This function serves as the kickoff point for the game loop itself\n     * and handles properly calling the update and render methods.\n     */\n    function main() {\n        /* Get our time delta information which is required if your game\n         * requires smooth animation. Because everyone's computer processes\n         * instructions at different speeds we need a constant value that\n         * would be the same for everyone (regardless of how fast their\n         * computer is) - hurray time!\n         */\n        var now = Date.now(),\n            dt = (now - lastTime) / 1000.0;\n\n        /* Call our update/render functions, pass along the time delta to\n         * our update function since it may be used for smooth animation.\n         */\n        update(dt);\n        render();\n\n        /* Set our lastTime variable which is used to determine the time delta\n         * for the next time this function is called.\n         */\n        lastTime = now;\n\n        /* Use the browser's requestAnimationFrame function to call this\n         * function again as soon as the browser is able to draw another frame.\n         */\n        win.requestAnimationFrame(main);\n    }\n\n    /* This function does some initial setup that should only occur once,\n     * particularly setting the lastTime variable that is required for the\n     * game loop.\n     */\n    function init() {\n        reset();\n        lastTime = Date.now();\n        main();\n    }\n\n    /* This function is called by main (our game loop) and itself calls all\n     * of the functions which may need to update entity's data. Based on how\n     * you implement your collision detection (when two entities occupy the\n     * same space, for instance when your character should die), you may find\n     * the need to add an additional function call here. For now, we've left\n     * it commented out - you may or may not want to implement this\n     * functionality this way (you could just implement collision detection\n     * on the entities themselves within your app.js file).\n     */\n    function update(dt) {\n        updateEntities(dt);\n        // checkCollisions();\n    }\n\n    /* This is called by the update function and loops through all of the\n     * objects within your allEnemies array as defined in app.js and calls\n     * their update() methods. It will then call the update function for your\n     * player object. These update methods should focus purely on updating\n     * the data/properties related to the object. Do your drawing in your\n     * render methods.\n     */\n    function updateEntities(dt) {\n        allEnemies.forEach(function(enemy) {\n            enemy.update(dt);\n        });\n        player.update();\n    }\n\n    /* This function initially draws the \"game level\", it will then call\n     * the renderEntities function. Remember, this function is called every\n     * game tick (or loop of the game engine) because that's how games work -\n     * they are flipbooks creating the illusion of animation but in reality\n     * they are just drawing the entire screen over and over.\n     */\n    function render() {\n        /* This array holds the relative URL to the image used\n         * for that particular row of the game level.\n         */\n        var rowImages = [\n                'images/water-block.png',   // Top row is water\n                'images/stone-block.png',   // Row 1 of 3 of stone\n                'images/stone-block.png',   // Row 2 of 3 of stone\n                'images/stone-block.png',   // Row 3 of 3 of stone\n                'images/grass-block.png',   // Row 1 of 2 of grass\n                'images/grass-block.png'    // Row 2 of 2 of grass\n            ],\n            numRows = 6,\n            numCols = 5,\n            row, col;\n\n        // Before drawing, clear existing canvas\n        ctx.clearRect(0,0,canvas.width,canvas.height)\n\n        /* Loop through the number of rows and columns we've defined above\n         * and, using the rowImages array, draw the correct image for that\n         * portion of the \"grid\"\n         */\n        for (row = 0; row < numRows; row++) {\n            for (col = 0; col < numCols; col++) {\n                /* The drawImage function of the canvas' context element\n                 * requires 3 parameters: the image to draw, the x coordinate\n                 * to start drawing and the y coordinate to start drawing.\n                 * We're using our Resources helpers to refer to our images\n                 * so that we get the benefits of caching these images, since\n                 * we're using them over and over.\n                 */\n                ctx.drawImage(Resources.get(rowImages[row]), col * 101, row * 83);\n            }\n        }\n\n        renderEntities();\n    }\n\n    /* This function is called by the render function and is called on each game\n     * tick. Its purpose is to then call the render functions you have defined\n     * on your enemy and player entities within app.js\n     */\n    function renderEntities() {\n        /* Loop through all of the objects within the allEnemies array and call\n         * the render function you have defined.\n         */\n        allEnemies.forEach(function(enemy) {\n            enemy.render();\n        });\n\n        player.render();\n    }\n\n    /* This function does nothing but it could have been a good place to\n     * handle game reset states - maybe a new game menu or a game over screen\n     * those sorts of things. It's only called once by the init() method.\n     */\n    function reset() {\n        // noop\n    }\n\n    /* Go ahead and load all of the images we know we're going to need to\n     * draw our game level. Then set init as the callback method, so that when\n     * all of these images are properly loaded our game will start.\n     */\n    Resources.load([\n        'images/stone-block.png',\n        'images/water-block.png',\n        'images/grass-block.png',\n        'images/enemy-bug.png',\n        'images/char-boy.png'\n    ]);\n    Resources.onReady(init);\n\n    /* Assign the canvas' context object to the global variable (the window\n     * object when run in a browser) so that developers can use it more easily\n     * from within their app.js files.\n     */\n    global.ctx = ctx;\n})(this);\n"]}