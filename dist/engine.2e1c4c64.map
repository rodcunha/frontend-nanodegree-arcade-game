{"version":3,"sources":["js\\engine.js"],"names":["Engine","global","doc","document","win","window","canvas","createElement","ctx","getContext","lastTime","width","height","main","appendChild","now","Date","dt","update","render","requestAnimationFrame","init","reset","updateEntities","allEnemies","forEach","enemy","player","rowImages","numRows","numCols","row","col","clearRect","drawImage","Resources","get","renderEntities","load","onReady"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;AAeA,IAAIA,SAAU,UAASC,MAAT,EAAiB;AAC3B;;;;AAIA,QAAIC,MAAMD,OAAOE,QAAjB;AAAA,QACIC,MAAMH,OAAOI,MADjB;AAAA,QAEIC,SAASJ,IAAIK,aAAJ,CAAkB,QAAlB,CAFb;AAAA,QAGIC,MAAMF,OAAOG,UAAP,CAAkB,IAAlB,CAHV;AAAA,QAIIC,QAJJ;;AAMAJ,WAAOK,KAAP,GAAe,GAAf;AACAL,WAAOM,MAAP,GAAgB,GAAhB;AACAV,QAAIW,IAAJ,CAASC,WAAT,CAAqBR,MAArB;;AAEA;;;AAGA,aAASO,IAAT,GAAgB;AACZ;;;;;;AAMA,YAAIE,MAAMC,KAAKD,GAAL,EAAV;AAAA,YACIE,KAAK,CAACF,MAAML,QAAP,IAAmB,MAD5B;;AAGA;;;AAGAQ,eAAOD,EAAP;AACAE;;AAEA;;;AAGAT,mBAAWK,GAAX;;AAEA;;;AAGAX,YAAIgB,qBAAJ,CAA0BP,IAA1B;AACH;;AAED;;;;AAIA,aAASQ,IAAT,GAAgB;AACZC;AACAZ,mBAAWM,KAAKD,GAAL,EAAX;AACAF;AACH;;AAED;;;;;;;;;AASA,aAASK,MAAT,CAAgBD,EAAhB,EAAoB;AAChBM,uBAAeN,EAAf;AACA;AACH;;AAED;;;;;;;AAOA,aAASM,cAAT,CAAwBN,EAAxB,EAA4B;AACxBO,mBAAWC,OAAX,CAAmB,UAASC,KAAT,EAAgB;AAC/BA,kBAAMR,MAAN,CAAaD,EAAb;AACH,SAFD;AAGAU,eAAOT,MAAP;AACH;;AAED;;;;;;AAMA,aAASC,MAAT,GAAkB;AACd;;;AAGA,YAAIS,YAAY,CACR,wBADQ,EACoB;AAC5B,gCAFQ,EAEoB;AAC5B,gCAHQ,EAGoB;AAC5B,gCAJQ,EAIoB;AAC5B,gCALQ,EAKoB;AAC5B,gCANQ,CAMoB;AANpB,SAAhB;AAAA,YAQIC,UAAU,CARd;AAAA,YASIC,UAAU,CATd;AAAA,YAUIC,GAVJ;AAAA,YAUSC,GAVT;;AAYA;AACAxB,YAAIyB,SAAJ,CAAc,CAAd,EAAgB,CAAhB,EAAkB3B,OAAOK,KAAzB,EAA+BL,OAAOM,MAAtC;;AAEA;;;;AAIA,aAAKmB,MAAM,CAAX,EAAcA,MAAMF,OAApB,EAA6BE,KAA7B,EAAoC;AAChC,iBAAKC,MAAM,CAAX,EAAcA,MAAMF,OAApB,EAA6BE,KAA7B,EAAoC;AAChC;;;;;;;AAOAxB,oBAAI0B,SAAJ,CAAcC,UAAUC,GAAV,CAAcR,UAAUG,GAAV,CAAd,CAAd,EAA6CC,MAAM,GAAnD,EAAwDD,MAAM,EAA9D;AACH;AACJ;;AAEDM;AACH;;AAED;;;;AAIA,aAASA,cAAT,GAA0B;AACtB;;;AAGAb,mBAAWC,OAAX,CAAmB,UAASC,KAAT,EAAgB;AAC/BA,kBAAMP,MAAN;AACH,SAFD;;AAIAQ,eAAOR,MAAP;AACH;;AAED;;;;AAIA,aAASG,KAAT,GAAiB,CAEhB;AADG;;;AAGJ;;;;AAIAa,cAAUG,IAAV,CAAe,CACX,wBADW,EAEX,wBAFW,EAGX,wBAHW,EAIX,sBAJW,EAKX,qBALW,CAAf;AAOAH,cAAUI,OAAV,CAAkBlB,IAAlB;;AAEA;;;;AAIApB,WAAOO,GAAP,GAAaA,GAAb;AACH,CAzKY,CAyKV,IAzKU,CAAb","file":"engine.2e1c4c64.map","sourcesContent":["/* Engine.js\r\n * This file provides the game loop functionality (update entities and render),\r\n * draws the initial game board on the screen, and then calls the update and\r\n * render methods on your player and enemy objects (defined in your app.js).\r\n *\r\n * A game engine works by drawing the entire game screen over and over, kind of\r\n * like a flipbook you may have created as a kid. When your player moves across\r\n * the screen, it may look like just that image/character is moving or being\r\n * drawn but that is not the case. What's really happening is the entire \"scene\"\r\n * is being drawn over and over, presenting the illusion of animation.\r\n *\r\n * This engine makes the canvas' context (ctx) object globally available to make\r\n * writing app.js a little simpler to work with.\r\n */\r\n\r\nvar Engine = (function(global) {\r\n    /* Predefine the variables we'll be using within this scope,\r\n     * create the canvas element, grab the 2D context for that canvas\r\n     * set the canvas elements height/width and add it to the DOM.\r\n     */\r\n    var doc = global.document,\r\n        win = global.window,\r\n        canvas = doc.createElement('canvas'),\r\n        ctx = canvas.getContext('2d'),\r\n        lastTime;\r\n\r\n    canvas.width = 505;\r\n    canvas.height = 606;\r\n    doc.main.appendChild(canvas);\r\n\r\n    /* This function serves as the kickoff point for the game loop itself\r\n     * and handles properly calling the update and render methods.\r\n     */\r\n    function main() {\r\n        /* Get our time delta information which is required if your game\r\n         * requires smooth animation. Because everyone's computer processes\r\n         * instructions at different speeds we need a constant value that\r\n         * would be the same for everyone (regardless of how fast their\r\n         * computer is) - hurray time!\r\n         */\r\n        var now = Date.now(),\r\n            dt = (now - lastTime) / 1000.0;\r\n\r\n        /* Call our update/render functions, pass along the time delta to\r\n         * our update function since it may be used for smooth animation.\r\n         */\r\n        update(dt);\r\n        render();\r\n\r\n        /* Set our lastTime variable which is used to determine the time delta\r\n         * for the next time this function is called.\r\n         */\r\n        lastTime = now;\r\n\r\n        /* Use the browser's requestAnimationFrame function to call this\r\n         * function again as soon as the browser is able to draw another frame.\r\n         */\r\n        win.requestAnimationFrame(main);\r\n    }\r\n\r\n    /* This function does some initial setup that should only occur once,\r\n     * particularly setting the lastTime variable that is required for the\r\n     * game loop.\r\n     */\r\n    function init() {\r\n        reset();\r\n        lastTime = Date.now();\r\n        main();\r\n    }\r\n\r\n    /* This function is called by main (our game loop) and itself calls all\r\n     * of the functions which may need to update entity's data. Based on how\r\n     * you implement your collision detection (when two entities occupy the\r\n     * same space, for instance when your character should die), you may find\r\n     * the need to add an additional function call here. For now, we've left\r\n     * it commented out - you may or may not want to implement this\r\n     * functionality this way (you could just implement collision detection\r\n     * on the entities themselves within your app.js file).\r\n     */\r\n    function update(dt) {\r\n        updateEntities(dt);\r\n        // checkCollisions();\r\n    }\r\n\r\n    /* This is called by the update function and loops through all of the\r\n     * objects within your allEnemies array as defined in app.js and calls\r\n     * their update() methods. It will then call the update function for your\r\n     * player object. These update methods should focus purely on updating\r\n     * the data/properties related to the object. Do your drawing in your\r\n     * render methods.\r\n     */\r\n    function updateEntities(dt) {\r\n        allEnemies.forEach(function(enemy) {\r\n            enemy.update(dt);\r\n        });\r\n        player.update();\r\n    }\r\n\r\n    /* This function initially draws the \"game level\", it will then call\r\n     * the renderEntities function. Remember, this function is called every\r\n     * game tick (or loop of the game engine) because that's how games work -\r\n     * they are flipbooks creating the illusion of animation but in reality\r\n     * they are just drawing the entire screen over and over.\r\n     */\r\n    function render() {\r\n        /* This array holds the relative URL to the image used\r\n         * for that particular row of the game level.\r\n         */\r\n        var rowImages = [\r\n                'images/water-block.png',   // Top row is water\r\n                'images/stone-block.png',   // Row 1 of 3 of stone\r\n                'images/stone-block.png',   // Row 2 of 3 of stone\r\n                'images/stone-block.png',   // Row 3 of 3 of stone\r\n                'images/grass-block.png',   // Row 1 of 2 of grass\r\n                'images/grass-block.png'    // Row 2 of 2 of grass\r\n            ],\r\n            numRows = 6,\r\n            numCols = 5,\r\n            row, col;\r\n\r\n        // Before drawing, clear existing canvas\r\n        ctx.clearRect(0,0,canvas.width,canvas.height)\r\n\r\n        /* Loop through the number of rows and columns we've defined above\r\n         * and, using the rowImages array, draw the correct image for that\r\n         * portion of the \"grid\"\r\n         */\r\n        for (row = 0; row < numRows; row++) {\r\n            for (col = 0; col < numCols; col++) {\r\n                /* The drawImage function of the canvas' context element\r\n                 * requires 3 parameters: the image to draw, the x coordinate\r\n                 * to start drawing and the y coordinate to start drawing.\r\n                 * We're using our Resources helpers to refer to our images\r\n                 * so that we get the benefits of caching these images, since\r\n                 * we're using them over and over.\r\n                 */\r\n                ctx.drawImage(Resources.get(rowImages[row]), col * 101, row * 83);\r\n            }\r\n        }\r\n\r\n        renderEntities();\r\n    }\r\n\r\n    /* This function is called by the render function and is called on each game\r\n     * tick. Its purpose is to then call the render functions you have defined\r\n     * on your enemy and player entities within app.js\r\n     */\r\n    function renderEntities() {\r\n        /* Loop through all of the objects within the allEnemies array and call\r\n         * the render function you have defined.\r\n         */\r\n        allEnemies.forEach(function(enemy) {\r\n            enemy.render();\r\n        });\r\n\r\n        player.render();\r\n    }\r\n\r\n    /* This function does nothing but it could have been a good place to\r\n     * handle game reset states - maybe a new game menu or a game over screen\r\n     * those sorts of things. It's only called once by the init() method.\r\n     */\r\n    function reset() {\r\n        // noop\r\n    }\r\n\r\n    /* Go ahead and load all of the images we know we're going to need to\r\n     * draw our game level. Then set init as the callback method, so that when\r\n     * all of these images are properly loaded our game will start.\r\n     */\r\n    Resources.load([\r\n        'images/stone-block.png',\r\n        'images/water-block.png',\r\n        'images/grass-block.png',\r\n        'images/enemy-bug.png',\r\n        'images/char-boy.png'\r\n    ]);\r\n    Resources.onReady(init);\r\n\r\n    /* Assign the canvas' context object to the global variable (the window\r\n     * object when run in a browser) so that developers can use it more easily\r\n     * from within their app.js files.\r\n     */\r\n    global.ctx = ctx;\r\n})(this);\r\n"]}